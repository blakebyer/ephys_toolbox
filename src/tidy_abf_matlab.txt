clear all; close all;
% Clear out variables to start fresh each time you run.

%% Code to loop through and read every matlab file

% % Specify the folder and file type
folderPath = 'C:\Users\bbyer\OneDrive\Documents\UniversityofKentucky\BachstetterLab\ephys_analysis';   % <-- change to your folder
fileType   = '*.abf';
% Get list of all files with that file type
files = dir(fullfile(folderPath, fileType));

% Add functions to path
addpath('C:\Users\bbyer\OneDrive\Documents\UniversityofKentucky\BachstetterLab\ephys_analysis\functions');

% Start with an empty table
AllDataTables = table();
%Loop through each file
for k = 1:length(files)
    % Get full file name
    input_file = fullfile(folderPath, files(k).name);

    %% USER INPUTS READ HERE
    %The number of technical replicates per stim intensity
    repnum=3;

    %if you want all individual graphs to export or not. The summary graph is not effected by this Put 1 for yes
    graphicsexport=0;

    %If you run the program and it looks bad, alter these manually
    %the maximum allowable FV start and minimum allowable FV end
    % which will mark when the program is not working. In ms.
    FV_end_min_ms=1.2;
    FV_start_max_ms=1.5;

    %the maximum allowable FV start and minimum allowable FV end
    % which will mark when the program is not working. In ms.

    %The window in which it will search for FV values
    FV_min_window_ms=0.1;
    FV_max_window_ms=2.5;

    %%END USER INPUTS

    % Split into folder, base filename, and extension
    [folder, baseFileName, ext] = fileparts(input_file);

    % Recombine without the extension
    output_location_NoExt = fullfile(folder, baseFileName);

    % Excel outputs name.
    % If you want to change your file name, comment the nextline and uncomment the line after that
    output_name =  output_location_NoExt;
    % output_name="input file name you want here"

    % define stimulation artifact cuttoff time in ms
    stim_artifact_cut = 1;

    % define time before stimulus to develop a baseline in ms
    pre_artifact_base_cut=.3;

    % provide list of stimulating currents
    current_sweep_list = {"amp25","amp50","amp75","amp100","amp150","amp200","amp250","amp300","amp400","amp500","amp600"}

    %% load in abf file and pull out traces, sampling freq, and meta data and reorganize into structures for each stimulating amp
    [batch_traces,sampling,meta_data] = abfload(input_file);

    %converst FV and EPSP min into the same units as everything else
    FV_end_min= FV_end_min_ms*1000/sampling;
    FV_start_max= FV_start_max_ms*1000/sampling;
    FV_min_window=FV_min_window_ms*1000/sampling;
    FV_max_window=FV_max_window_ms*1000/sampling;

    % cut traces to point after stimulation artifact
    start_indx = (stim_artifact_cut*1000)/sampling;
    batch_traces = squeeze(batch_traces);

    % make structure with technical repeats for each of the stimulating amps
    file_counter1 = 1;
    for i = 1:width(current_sweep_list);
        raw_trace.(current_sweep_list{i}) = batch_traces(start_indx:end,file_counter1:file_counter1+2);
        file_counter1 = file_counter1+repnum;
    end

    % make structure with averages of each technical repeat
    for i = 1:width(current_sweep_list);
        average.(current_sweep_list{i}) = mean(raw_trace.(current_sweep_list{i}),2);
    end

    % set colormap
    cmap = colormap(parula(width(current_sweep_list)));

    % calculate RMSE for the average compared to each individual trace
    for i = 1: width(current_sweep_list);
        RMSE_average(i,:) = rmse(raw_trace.(current_sweep_list{i}),average.(current_sweep_list{i}))
    end

    %% Find the average and standard deviation of the baseline for when the baseline is not zero

    % make structure for baseline with technical repeats for each of the stimulating amps
    base_idx = round(pre_artifact_base_cut * 1000)/sampling;
    file_counter1 = 1;

    for i2 = 1:width(current_sweep_list)
        raw_trace_base.(current_sweep_list{i2}) = batch_traces(1:base_idx,file_counter1:file_counter1+2);
        file_counter1 = file_counter1+3;
    end

    % average the three samples
    for i = 1:width(current_sweep_list)
        base.(current_sweep_list{i}) = mean(raw_trace_base.(current_sweep_list{i}),2);
        average_base(i)=mean(base.(current_sweep_list{i}));
    end



    %% Analyze traces for FVamp,EPSPamp,EPSP slope, and search for pop spikes
    for i = width(current_sweep_list):-1:1
        figure(1)
        %% find EPSP amp
        smooth_sweeplist= smoothdata(average.(current_sweep_list{i}),"movmean",4)
        df=diff(smooth_sweeplist);
        smooth_df_rloess = smoothdata(df,"rloess");
        [max_df,max_df_indx]=max(smooth_df_rloess);
        [epsp_min_val(i,:), epsp_min_indx(i,:)] = min(smooth_sweeplist(1:max_df_indx));

        %Adjust EPSP minimum if it is way off in time from other epsp minimums
        if i==width(current_sweep_list)
            epsp_min_min_window=epsp_min_indx(i)-30;
            epsp_min_max_window=epsp_min_indx(i)+30;
            last_good_epsp_min_indx=epsp_min_indx(i);
        else
            if epsp_min_indx(i)>epsp_min_min_window && epsp_min_indx(i)<epsp_min_max_window
                last_good_epsp_min_indx=epsp_min_indx(i);
                epsp_min_min_window=epsp_min_indx(i)-30;
                epsp_min_max_window=epsp_min_indx(i)+30;
            else
                epsp_min_indx(i)=last_good_epsp_min_indx;
                epsp_min_val(i)=average.(current_sweep_list{i})(epsp_min_indx(i));
            end

        end

        %% find FV points and amplitude
        tiledlayout(4,2)
        nexttile
        hold on
        plot(average.(current_sweep_list{i}))

        yyaxis right
        plot(smooth_df_rloess)
        title(current_sweep_list{i})
        legend({'average trace','approx derivative'},'Location','southeast')


        nexttile(3)
        % find peaks of first derivative
        findpeaks(smooth_df_rloess)
        %HW added peak width and peak prominence
        [pks_val,pks_indx,pks_width,pks_prom] = findpeaks(smooth_df_rloess);
        title("Attempt to find shoulder peaks")

        %% If two peaks in window, use easy method, 
        %  If no peaks in window,
        % remove data smoothing then use previous method. Avoiding error
        % where oversmoothed data has no or only 1 peak in window.

        if pks_indx(1,1)>FV_min_window && pks_indx(1,1)<FV_start_max && pks_indx(2,1)<FV_max_window && pks_indx(2,1)>FV_end_min
            fv_start(i) = pks_indx(1,1);
            fv_end(i) = pks_indx(2,1);
            fv_last_good_start=fv_start(i);
            fv_last_good_end=fv_end(i);
        else
            %only smooth df, not data
            df = diff(average.(current_sweep_list{i}));
          
            %Find location and size of peaks in derivative
            [pks_val,pks_indx,pks_width,pks_prom] = findpeaks(smooth_df_rloess);

            % Find peaks in a specific window
            i2=1;
            for i3=1:length(pks_indx)
                if pks_indx(i3)>FV_min_window &&pks_indx(i3)<FV_max_window
                    pks_prom_window(i2)=pks_prom(i3);
                    pks_index_window(i2)=pks_indx(i3);
                    i2=i2+1;
                else
                    %do nothing
                end
            end

            %find largest peaks within that window
            [sortedValues, sortedindx]=sort(pks_prom_window,'descend');

            %for loops starts as biggest amplitude. When the FV looks wrong, is
            %uses the previous amp's FV

            if i==width(current_sweep_list)
                % determine which of the largest peaks is first
                if sortedindx(1)>sortedindx(2)
                    fv_start(i)=pks_index_window(sortedindx(2));
                    fv_end(i)=pks_index_window(sortedindx(1));
                else
                    fv_start(i)=pks_index_window(sortedindx(1));
                    fv_end(i)=pks_index_window(sortedindx(2));
                end
                % if the FV seems reasonable, use it as the baseline if the next FV
                % doesn't look reasonable. If it doesn't look reasonable, use the
                % window.

                if fv_end(i)>FV_end_min
                    fv_last_good_end=fv_end(i);
                else
                    fv_last_good_end=FV_max_window;
                end

                if fv_start(i)<FV_start_max
                    fv_last_good_start=fv_start(i);
                else
                    fv_last_good_start=FV_min_window;
                end

            else
                %Now that we have fv__last_good_start and end determined, can use
                %the previous amplitude if necessary

                numpeaks=length(sortedindx);
                if numpeaks>1
                    % determine which peak corresponds to FV start and
                    % which is FV end
                    if sortedindx(1)>sortedindx(2)
                        fv_start(i)=pks_index_window(sortedindx(2));
                        fv_end(i)=pks_index_window(sortedindx(1));
                    else
                        fv_start(i)=pks_index_window(sortedindx(1));
                        fv_end(i)=pks_index_window(sortedindx(2));
                    end
                    % Determines if our FV start and end values are
                    % reasonable. If not, default to previous FV start/end
                    if fv_end(i)>=(fv_last_good_end-3)&&fv_end(i)<=(fv_last_good_end+6)
                        fv_last_good_end=fv_end(i)+1;
                    else
                        fv_end(i)= fv_last_good_end;
                    end

                    if fv_start(i)>=(fv_last_good_start-1)&&fv_end(i)<=(fv_last_good_start+4)
                        fv_last_good_start=fv_start(i);
                    else
                        fv_start(i)=fv_last_good_start;
                    end

                else
                    fv_end(i)= fv_last_good_end;
                    fv_start(i)=fv_last_good_start;
                    fv_last_good_end=fv_last_good_end+1;
                end
            end
        end


        % plot FV points on orginical trace
        nexttile(5)
        hold on
        plot(average.(current_sweep_list{i}))
        plot(fv_start(i)+1,average.(current_sweep_list{i})(fv_start(i)+1),'Marker',"o","MarkerFaceColor","r","MarkerEdgeColor","k")
        plot(fv_end(i)+1,average.(current_sweep_list{i})(fv_end(i)+1),'Marker',"s","MarkerFaceColor","c","MarkerEdgeColor","k")
        title("Place FV amplitude markers")

        %Calculate fv_val
        fv_val(i,:) = average.(current_sweep_list{i})(fv_start(i)+1) - average.(current_sweep_list{i})(fv_end(i)+1);


        
        %% Calculate EPSP slope

        EPSP_slope_min=fv_end(i)+5;
        EPSP_slope_max=epsp_min_indx(i);

        nexttile(2)
        hold on
        %smooth the trace using a gaussian filter then take derivative
        smoothed_data = smoothdata(average.(current_sweep_list{i}),"gaussian");
        smoothed_df = diff(smoothed_data);
        %find portion of curve with greatest decrease
        %Addition: The greatest negative derivative after the EPSP min.
        [slope_val(i,:), slope_indx(i,:)] = min(smooth_df_rloess(EPSP_slope_min:EPSP_slope_max));
        plot(average.(current_sweep_list{i}))
        plot(smoothed_data)
        plot(slope_indx(i,:)+EPSP_slope_min,average.(current_sweep_list{i})(slope_indx(i,:)+EPSP_slope_min),'g*')
        yyaxis right
        plot(smooth_df_rloess,'r')
        % Trying to get a better gaussian fit Didn't work so commenting
        % out, but may be useful should you further adapt the code.
        % x_fit = [epsp_min_indx(i,:):200];
        % x_fit=[1:length(average.(current_sweep_list{i}))];
        % initial_centroid =  epsp_min_indx(i); % Set initial centroid to the minimum of the data
        % f = fit(x_fit.', average.(current_sweep_list{i}), 'gauss1', 'StartPoint', [epsp_min_val(i), initial_centroid, 1]);
        % plot(f)
        legend({'Original trace','Gaussian smoothed traced','Point of maximum decrease','Approx derivative of smoothed'},'Location','southeast')
        title('Find middle of EPSP slope')

        % initial_centroid =  epsp_min_indx(i); % Set initial centroid to the minimum of the data
        %     f = fit(x_fit(1:end-1).', average.(current_sweep_list{i}).', 'gauss1', 'StartPoint', [epsp_min_val(i), initial_centroid, 1]);





        nexttile(4)
        fit_distance = 4;
        hold on
        plot(average.(current_sweep_list{i}))
        plot(slope_indx(i,:)+EPSP_slope_min,average.(current_sweep_list{i})(slope_indx(i,:)+EPSP_slope_min),"g*")
        %fit lin reg around the point with the greatest negative slope
        x_fit = [(slope_indx(i,:)+EPSP_slope_min-fit_distance):(slope_indx(i,:)+EPSP_slope_min+fit_distance)];
        mdl = fitlm(x_fit,average.(current_sweep_list{i})(x_fit));
        slope_points.(current_sweep_list{i})(:,1) = mdl.Variables.x1
        slope_points.(current_sweep_list{i})(:,2) = mdl.Fitted
        slopes(i,:) = mdl.Coefficients.Estimate(2)*1000/sampling;
        plot(mdl)
        title('Fit linear regression to EPSP slope')
        legend({'Original trace','EPSP midpoint','','Fit','95% CI'})
        hold off

        %% Check for pop spike. This bit doesn't work well yet and can only identify large pop-spikes.
        nexttile(6)
        if i>12
            title('Get smoothed derivative after the EPSP point')
            hold on
            x_fit = [epsp_min_indx(i,:):200]
            plot(average.(current_sweep_list{i})(x_fit))
            yyaxis right
            df1= smoothdata(diff(average.(current_sweep_list{i})(x_fit)))
            df2 = gradient(average.(current_sweep_list{i})(x_fit))
            plot(df1)
            legend({'Orginal Trace','Approx derivative smoothed'},'Location','southeast')
            hold off

            %fit gaussian to smoothed derivative
            [fit_gaus,good_gaus]  = fit(x_fit(1:end-1)',df1,'gauss3')
            fitval_gaus.rsq(i) = good_gaus.adjrsquare
            %smoothed_data

            % Fit a Gaussian model with the centroid starting at the data minimum
            initial_centroid =  epsp_min_indx(i); % Set initial centroid to the minimum of the data
            f = fit(x_fit(1:end-1).', average.(current_sweep_list{i}).', 'gauss3', 'StartPoint', [epsp_min_val(i), initial_centroid, 1]);

            nexttile(8)
            hold on
            plot(fit_gaus,x_fit(1:end-1)',df1)
            title('Gaussian fit to smoothed derivative')
            legend(Location="southeast")
        else
            %do nothing
        end

        sgtitle(input_file)
        file_name = output_name
        file_path = join([output_name,current_sweep_list{i}],"_")
        file_path = join([file_path,"png"],".")

        %Create structure for table outputs

        FV_end_min_user_input=repmat(FV_end_min_ms,width(current_sweep_list),1);
        FV_start_max_user_input=repmat(FV_start_max_ms,width(current_sweep_list),1);

        % correct ESPS amp

        epsp_min_val_corrected(i)=epsp_min_val(i)-average_base(i);

        tempstruct.filepath(i,:)= {input_file}
        tempstruct.filename(i,:) = {file_name}
        tempstruct.stim_current(i,:) = current_sweep_list{i}
        tempstruct.FV_amplitude(i,:) = fv_val(i,:)
        tempstruct.EPSE_slope_mVperuS(i,:) = mdl.Coefficients.Estimate(2)*1000/sampling*1000
        tempstruct.EPSP_amplitude_mV(i,:) = epsp_min_val_corrected(i)
        tempstruct.EPSE_slope_Rsq(i,:) = mdl.Rsquared.Adjusted
        tempstruct.EPSE_to_FV(i,:) = epsp_min_val(i)/fv_val(i,:)
        tempstruct.FV_end_min_user_input=FV_end_min_user_input
        tempstruct.FV_start_max_user_input=FV_start_max_user_input
    end
    out_table = struct2table(tempstruct);

    %name the table and make it export as an excel sheet
    filepath_table1=join([output_name,"xlsx"],".");
    writetable(out_table,filepath_table1)

    AllDataTables = [AllDataTables;out_table];

    %% plot summary figure of analysis
    figure(2)
    t = tiledlayout(1,1);
    nexttile([1 1])
    %find and plot EPSP
    for i = 1: width(current_sweep_list);
        hold on
        plot(average.(current_sweep_list{i}),'Color',cmap(i,:),'LineWidth',1)
        plot(raw_trace.(current_sweep_list{i})(:,1),'Color','k','LineStyle',':')
        plot(raw_trace.(current_sweep_list{i})(:,2),'Color','k','LineStyle',':')
        plot(raw_trace.(current_sweep_list{i})(:,3),'Color','k','LineStyle',':')
        plot(fv_start(i)+1,average.(current_sweep_list{i})(fv_start(i)+1),'Marker',"o","MarkerFaceColor","r","MarkerEdgeColor","k")
        plot(fv_end(i)+1,average.(current_sweep_list{i})(fv_end(i)+1),'Marker',"s","MarkerFaceColor","c","MarkerEdgeColor","k")
        plot(epsp_min_indx(i,:),epsp_min_val(i,:),'Marker',"v","MarkerFaceColor","m","MarkerEdgeColor","k")
        plot(slope_indx(i),average.(current_sweep_list{i})(slope_indx(i)),"m*")
        plot(slope_points.(current_sweep_list{i})(:,1),slope_points.(current_sweep_list{i})(:,2),'LineWidth',1,'Color','r')
        ylabel('mV')
        titleadd=string(files(k).name);
        title(titleadd)
    end

    % nexttile
    % plot(RMSE_average,'ro')
    % xticklabels(current_sweep_list)
    % ylabel ({'RMSE','AverageTrace'})

    %%This will plot the pop-spike, commenting out because right now it doesn't
    %%work
    % nexttile
    % hold on
    % plot(fitval_gaus.rsq)
    % differ = diff(fitval_gaus.rsq)
    % plot(2:11,differ)
    % xticklabels(current_sweep_list(1:end))
    %
    % [pop_val, pop_indx] = (max(differ))
    % if fitval_gaus.rsq(pop_indx+1)> 0.5
    %     plot((pop_indx+1),fitval_gaus.rsq(pop_indx+1),'r*')
    %     pop_thresdhold_amp = current_sweep_list(pop_indx+1)
    % end
    % legend({'Rsquared of Gaussian fit','Change in Rsquared of Gaussian fit','first pop spike'})

    file_pathfig2 = join([file_name,"summary"],"_")
    file_pathfig2 = join([file_pathfig2,"png"],".")
    file_pathfig2 = join([file_pathfig2],"\")

    fig2 = findobj('Type', 'figure', 'Number', 2); % Get handle to Figure 2

    fname = files(k).name;
    % Split into name and extension
    [~, name, ~] = fileparts(fname);

    figNamer= join([name,"fig"],".")
    savefig(fig2,figNamer); % saves all versions of fig2
    figsave(k)=figNamer;

    exportgraphics(fig2, file_pathfig2); % Export Figure 2 as a PNG file

    if graphicsexport==1
        exportgraphics(gcf,file_path)
    else
    end


    for j = 1
        tempstruct2.filepath(j,:)= {input_file}
        tempstruct2.filename(j,:) = {file_name}
        tempstruct2.exp_date(j,:) = meta_data.uFileStartDate
        tempstruct2.Max_EPSP(j,:) = min(epsp_min_val)
        tempstruct2.Max_EPSP_slope(j,:) = min(slopes)
        %tempstruct2.pop_spike_stim_current(j,:) = {current_sweep_list((pop_indx+1))}
        %tempstruct2.pop_spike_thresh(j,:) = slopes(pop_indx+1)
        tempstruct2.EPSP_FV_stim600amp(j,:) = epsp_min_val(end)/fv_val(end,:)
        tempstruct2.EPSP_FV_stim500amp(j,:) = epsp_min_val(end-1)/fv_val(end-1,:)
        tempstruct2.EPSP_FV_stim400amp(j,:) = epsp_min_val(end-2)/fv_val(end-2,:)
    end
    out_table2 = struct2table(tempstruct2)
    %writetable(out_table2,'data_out.xlsx','Sheet','slice_data')
    % HW combine with previouswritetable after popspike fixed
end

tableoutput_name=join([folder,"AllTablesSummary"],"\");
filenameAllTable=join([tableoutput_name,"xlsx"],".");
% Output Combined Data Table
writetable(AllDataTables,filenameAllTable)

%% combine all of the figure 2's into a single file

N = numel(figsave);
nCols = ceil(sqrt(N));
nRows = ceil(N / nCols);

% Create destination figure with tiles
bigFig = figure('Name','Combined from .fig array','Color','w');
t = tiledlayout(bigFig, nRows, nCols, 'TileSpacing','compact','Padding','compact');

for k = 1:N
    % Open .fig invisibly
    srcFig = openfig(figsave{k}, 'invisible');

    % Destination tile
    destAx = nexttile(t, k);

    % Find source axes (ignoring legends/colorbars)
    srcAxes = findall(srcFig, 'Type','axes');
    srcAxes = srcAxes(~arrayfun(@(a) isa(a,'matlab.graphics.illustration.ColorBar'), srcAxes));

    if isempty(srcAxes)
        % Fallback: rasterize the figure
        fr = getframe(srcFig);
        imshow(fr.cdata, 'Parent', destAx);
        axis(destAx,'off');
    else
        % Copy children from first axes (or loop through all)
        srcAx = srcAxes(1);
        kids = allchild(srcAx);
        copyobj(kids, destAx);

        % Copy properties
        title(destAx, srcAx.Title.String);
        xlabel(destAx, srcAx.XLabel.String);
        ylabel(destAx, srcAx.YLabel.String);
        destAx.XLim = srcAx.XLim;
        destAx.YLim = srcAx.YLim;
    end

    % Close source figure to keep things tidy
    close(srcFig);
end

bigFigoutput_name=join([folder,"AllPlotsSummary"],"\");
bigFigoutput_name=join([bigFigoutput_name,"png"],".");

% Output Combined Data Table
exportgraphics(bigFig, bigFigoutput_name)